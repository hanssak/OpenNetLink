@using System.IO
@using BlazorInputFile
@using System.Diagnostics
@using OpenNetLinkApp.Services
@using HsNetWorkSG 

@inject IJSRuntime jsRuntime
@inject IFileReaderService fileReaderService
@inject XmlConfService XmlConf

<DropTarget Drop="@OnDrop">
    <div class="dropzone col-md-12 p-0" style="overflow:auto;height:166px;">
        <InputFile id="fileInput" multiple title=""
                   @onclick="HandleClick"
                   @ondragenter="HandleDragEnter"
                   @ondragleave="HandleDragLeave" />
        @if ((fileTypeError || fileSizeError))
        {
            <ul class="validation-errors mb-0">
                @if (fileTypeError)
                {
                    <li class="validation-message" style="font-size:14px;">Only image files are accepted.</li>
                }
                @if (fileSizeError)
                {
                    <li class="validation-message" style="font-size:14px;">The max file size is @MaxFileSizeMB MB.</li>
                }
            </ul>
        }
        <!-- height:100%;position:relative;left:0px;top:0px; -->
        <!--class="table table-head-fixed table-bordered table-hover mb-0" style="font-size: 14px; position: relative; left: 0px; top: 0px;" -->
        @if (selectedFiles != null && selectedFiles.Count > 0)
        {
            <table id="example2" class="table table-head-fixed table-bordered table-hover mb-0" style="font-size: 14px;">
                <thead>
                    <tr>
                        <th>@strFileName</th>                 <!--파일명-->
                        <th>@strFileSize</th>                 <!--크기-->
                        <th>@strFileType</th>                 <!--유형-->
                        <th>@strLastModDay</th>               <!--수정한 날짜-->
                    </tr>
                </thead>
                <tbody>
                    @foreach (var file in selectedFiles)
                    {
                        <tr style="height:20px;">
                            <td>@file.Name</td>
                            <td>@getSizeStr(file.Size)</td>
                            <td>@file.Type</td>
                            <td>@file.LastModified</td>
                        </tr>
                    }
                </tbody>
            </table>
        }
        else
        {
    <p style="font-size:15px;">
        <br /><br /><br />@strFileDragInfo<br /><br />         <!--파일을 이곳으로 드래그 하세요.-->
    </p>
        }
    </div>
</DropTarget>

@code {

    string strFileName = "";
    string strFileSize = "";
    string strFileType = "";
    string strLastModDay = "";
    string strRelativePath = "";
    string strFileDragInfo = "";

    const long MaxFileSizeMB = 5000;
    const long MaxFileSize = MaxFileSizeMB * 1024 * 1024; // 5MB
                                                          //private string dropClass = "";
    private bool fileSizeError = false;
    private bool fileTypeError = false;
    private List<FileListEntryImpl> selectedFiles = new List<FileListEntryImpl>();
    private static Action<FileListEntryImpl[]> action1;

    public ElementReference inputTypeFileElement;
    IFileReaderRef dropReference;

    List<HsStream> HsStreamList = new List<HsStream>();

    public async Task UploadFiles()
    {
        dropReference = fileReaderService.CreateReference(inputTypeFileElement);
        string targets = new string("fileInput");
        await dropReference.SetDragTargetElementAsync(targets);

        await dropReference.IsDragTargetElement(targets);
        System.Threading.Thread.Sleep(500);
        await dropReference.AppendDragTargetElement(targets);

        HsStream hsStream = null;
        foreach (var file in await dropReference.EnumerateFilesAsync())
        {
            hsStream = new HsStream();
            var fileInfo = await file.ReadFileInfoAsync();
            Debug.WriteLine("FileName:" + fileInfo.Path + fileInfo.Name);
            string strRelativePath = fileInfo.Path + fileInfo.Name;
            if (fileInfo.Dir == "Dir")
            {
                hsStream.Name = strRelativePath;
                DateTime date = (DateTime)fileInfo.LastModifiedDate;
                hsStream.MTime = date.ToString();
                hsStream.FileType = "DIRECTORY";
                hsStream.IsDir = true;
            }
            else
            {
                byte[] buffer = new byte[16 * 1024];
                using (MemoryStream memoryStream = await file.CreateMemoryStreamAsync(16 * 1024))
                {
                    try
                    {
                        int read = 0;
                        while ((read = memoryStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            hsStream.Seek(0, SeekOrigin.End);
                            hsStream.Write(buffer);
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex.StackTrace);
                    }

                    hsStream.Name = strRelativePath;
                    DateTime date = (DateTime)fileInfo.LastModifiedDate;
                    hsStream.MTime = date.ToString();
                    string strFileType = fileInfo.GetType().ToString();
                    if (strFileType.Equals("Archive"))
                    {
                        if (hsStream.Name.LastIndexOf(".") > -1)
                            hsStream.FileType = hsStream.Name.Substring(hsStream.Name.LastIndexOf(".") + 1);
                        else
                            hsStream.FileType = "";
                    }
                    hsStream.IsDir = false;
                }
            }
            HsStreamList.Add(hsStream);

        }

        //탐색기 전달파일 종료 및 UI 내부 Drag 파일 핸들링(디렉토리인경우 디렉토리 분기 타야함,DirFileSearch함수 참고)
        foreach (FileListEntryImpl item in selectedFiles)
        {
            try
            {
                hsStream = new HsStream();
                if (item.GetType().ToString().Equals("Directory"))
                {
                    hsStream.Name = item.RelativePath;
                    if (!hsStream.Name.Equals(item.StartPath))
                        hsStream.Name.Replace(item.StartPath, "");
                    DateTime date = (DateTime)item.LastModified;
                    hsStream.MTime = date.ToString();
                    hsStream.FileType = "DIRECTORY";
                    hsStream.IsDir = true;
                }
                else
                {
                    hsStream.Name = item.RelativePath;
                    if (!hsStream.Name.Equals(item.StartPath))
                        hsStream.Name.Replace(item.StartPath, "");
                    DateTime date = (DateTime)item.LastModified;
                    hsStream.MTime = date.ToString();
                    hsStream.FileType = item.Type;
                    hsStream.IsDir = false;
                    FileStream rfs;
                    rfs = new FileStream(item.RelativePath, FileMode.Open, FileAccess.Read);
                    rfs.CopyTo(hsStream);
                    rfs.Close();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.StackTrace);
            }

            HsStreamList.Add(hsStream);
        }

        await dropReference.ClearValue();
        await dropReference.initFileReaderService(targets);
        await dropReference.DelDragTargetElementAsync(targets);

        selectedFiles.Clear();
        StateHasChanged();

        string strMsg = XmlConf.GetInfoMsg("I_0029");   // 파일 전송이 완료되었습니다.
        string strSystemName = XmlConf.GetTitle("T_SYSTEMNAME");
        object[] param = { "success", strSystemName, strMsg };
        await jsRuntime.InvokeAsync<object>("fireToastMessage", param);

    }
    public async Task DataClear()
    {
        dropReference = fileReaderService.CreateReference(inputTypeFileElement);
        string targets = new string("fileInput");

        await dropReference.ClearValue();
        await dropReference.initFileReaderService(targets);
        await dropReference.DelDragTargetElementAsync(targets);

        selectedFiles.Clear();
        StateHasChanged();
    }
    private void ShowMessage(string strType, string strMsg)
    {
        //type: success, info, waring, error 2020/07/02 YKH
        string strSystemName = XmlConf.GetTitle("T_SYSTEMNAME2");                  // 망연계 솔루션
        strMsg = strMsg.Replace("/r/n", "<br/>");
        object[] param = { strType, strSystemName, strMsg };
        jsRuntime.InvokeAsync<object>("fireToastMessage", param);
    }

    //디렉토리 검색 함수
    void DirFileSearch(string path)
    {
        try
        {
            string[] dirs = Directory.GetDirectories(path);
            string[] files = Directory.GetFiles(path);
            foreach (string f in files)
            {
                //파일이면 파일을 복사하고(위코드참고) 
                Debug.WriteLine(f);
            }
            if (dirs.Length > 0)
            {
                foreach (string dir in dirs)
                {
                    Debug.WriteLine(dir);
                    //디렉토리면 디렉토리 만들고 System.IO.Directory.CreateDirectory(path);
                    DirFileSearch(dir);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    [JSInvokable("NotifyChange")]
    public static void NotifyChange(FileListEntryImpl[] files)
    {
        action1.Invoke(files);
    }

    void OnDrop(List<string> list)
    {
        for (int i = 0; i < list.Count; i++)
        {
            Console.WriteLine("File Dropped  {data}");
            string data = list[i];
            if (data != null && data.Length > 0)
            {
                bool bFind = false;
                foreach (var item in selectedFiles)
                {
                    if (item.RelativePath == data)
                    {
                        bFind = true;
                        break;
                    }
                }
                if (bFind == true)
                    continue;

                System.IO.FileInfo fInfo = new System.IO.FileInfo(data);
                FileAttributes attr = fInfo.Attributes;
                if ((attr & FileAttributes.Directory) != FileAttributes.Directory)
                {
                    FileListEntryImpl fileEntry = new FileListEntryImpl();
                    fileEntry.Name = fInfo.Name;
                    fileEntry.Size = fInfo.Length;
                    fileEntry.RelativePath = fInfo.FullName;
                    if (fInfo.Name.LastIndexOf(".") > -1)
                        fileEntry.Type = fInfo.Name.Substring(fInfo.Name.LastIndexOf(".")+1);
                    else
                        fileEntry.Type = "";
                    fileEntry.LastModified = fInfo.LastWriteTime;
                    selectedFiles.Add(fileEntry);
                }
                else if ((attr & FileAttributes.Directory) == FileAttributes.Directory)
                {
                    FileListEntryImpl fileEntry = new FileListEntryImpl();
                    fileEntry.Name = fInfo.Name;
                    fileEntry.Size = 0;
                    fileEntry.RelativePath = fInfo.FullName;
                    fileEntry.StartPath = fileEntry.RelativePath;
                    fileEntry.Type = fInfo.Attributes.ToString();
                    fileEntry.LastModified = fInfo.LastWriteTime;
                    List<System.IO.FileInfo> FileData = DirSearch(fileEntry.RelativePath);
                    foreach(var item in FileData)
                    {
                        FileAttributes attrSub = item.Attributes;
                        FileListEntryImpl fileSubEntry = new FileListEntryImpl();
                        fileSubEntry.Name = item.Name;
                        //fileSubEntry.Name = item.FullName;
                        fileSubEntry.Type = item.Attributes.ToString();
                        if(fileSubEntry.Type.Equals("Directory"))
                            fileSubEntry.Size = 0;
                        else
                            fileSubEntry.Size = item.Length;
                        if (fileSubEntry.Type.Equals("Archive"))
                        {
                            if (item.Name.LastIndexOf(".") > -1)
                                fileSubEntry.Type = item.Name.Substring(item.Name.LastIndexOf(".") + 1);
                            else
                                fileSubEntry.Type = "";
                        }
                        fileSubEntry.StartPath = fileEntry.StartPath;
                        fileSubEntry.RelativePath = item.FullName;
                        fileSubEntry.LastModified = item.LastWriteTime;
                        selectedFiles.Add(fileSubEntry);
                    }
                }
            }
        }
        // Important: Invoke StateHasChanged() to update the page
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        InitText();
        action1 = HandleFileInputChange;
    }
    private void onDrop()
    {
        Console.WriteLine("OnDrop Event Occured");
    }

    private void HandleDrop()
    {
        Console.WriteLine("HandleDrop Event Occured");
    }

    private void HandleClick()
    {
        Console.WriteLine("Click Event Occured");
    }

    private void HandleDragEnter()
    {
        //dropClass = "dropzone-drag";
    }

    private void HandleDragLeave()
    {
        //dropClass = "";
    }

    private void HandleFileInputChange(IFileListEntry[] files)
    {
        //dropClass = "";
        fileSizeError = false;
        fileTypeError = false;
        // Disable file type error-1
        //List<string> acceptedFileTypes = new List<string>() { "image/png", "image/jpeg", "image/gif" };
        if (files != null)
        {
            foreach (var file in files)
            {
                bool error = false;
                if (file.Size > MaxFileSize)
                {
                    error = true;
                    fileSizeError = true;
                }
                // Disable file type error-2
                //if (!acceptedFileTypes.Contains(file.Type))
                //{
                //    error = true;
                //    fileTypeError = true;
                //}
                //중복제거
                bool bFind = false;
                foreach (var item in selectedFiles)
                {
                    if (item.Name == file.Name)
                    {
                        bFind = true;
                        break;
                    }
                }
                if (bFind == true)
                    continue;


                //keep the good files
                if (!error)
                {
                    FileListEntryImpl fileEntry = new FileListEntryImpl();
                    fileEntry.Name = file.Name;
                    fileEntry.Size = file.Size;
                    fileEntry.Type = file.Type;
                    if (fileEntry.Type.Equals(""))
                        fileEntry.Type = "-";
                    fileEntry.RelativePath = file.RelativePath;
                    if (file.Name.LastIndexOf(".") > -1)
                        fileEntry.Type = file.Name.Substring(file.Name.LastIndexOf("."));
                    else
                        fileEntry.Type = "";
                    fileEntry.LastModified = file.LastModified;
                    selectedFiles.Add(fileEntry);
                }
            }
        }
        StateHasChanged();
    }

    private void RemoveFile(IFileListEntry file)
    {
        FileListEntryImpl fileEntry = new FileListEntryImpl();
        fileEntry.Name = file.Name;
        fileEntry.Size = file.Size;
        fileEntry.RelativePath = file.RelativePath;
        fileEntry.Type = file.GetType().FullName;

        selectedFiles.Remove(fileEntry);
    }

    public void RemoveAllFile()
    {
        selectedFiles.Clear();
        StateHasChanged();
    }

    //DropZone 클릭방지코드
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        return stopClick();
    }
    private async Task stopClick()
    {
        await jsRuntime.InvokeAsync<object>("stopClick");

        dropReference = fileReaderService.CreateReference(inputTypeFileElement);
        string targets = new string("fileInput");
        await dropReference.SetDragTargetElementAsync(targets);
        await dropReference.RegisterDropEventsAsync(true);
    }

    public void InitText()
    {

        strFileName = XmlConf.GetTitle("T_COMMON_FILENAME");                   // 파일명
        strFileSize = XmlConf.GetTitle("T_COMMON_SIZE");                       // 크기
        strFileType = XmlConf.GetTitle("T_COMMON_KIND");                       // 유형
        strLastModDay = XmlConf.GetTitle("T_COMMON_MODIFYDATE");               // 수정한 날짜.
        strRelativePath = XmlConf.GetTitle("T_FILE_PATH");                     // 경로
        strFileDragInfo = XmlConf.GetInfoMsg("I_0189");                        // 파일을 이곳으로 드래그 하세요.
    }

    public string getSizeStr(long Size)
    {
        string rtn = "";
        if (Size == 0)
        {
            rtn = "";
        }
        if (Size > 1024 * 1024 * 1024)
        {
            float nSize = (float)Size / (1024 * 1024 * 1024);
            rtn = nSize.ToString("####0.0") + "GB";
        }
        else if (Size > 1024 * 1024)
        {
            float nSize = (float)Size / (1024 * 1024);
            rtn = nSize.ToString("####0.0") + "MB";
        }
        else if (Size > 1024)
        {
            float nSize = (float)Size / (1024);
            rtn = nSize.ToString("####0.0") + "KB";
        }
        else if (Size > 0)
            rtn = Size + " Byte";
        return rtn;
    }


    public List<System.IO.FileInfo> DirSearch(string sDir, List<System.IO.FileInfo> temp = null)
    {
        if (temp == null)
            temp = new List<System.IO.FileInfo>();
        DirectoryInfo di = new DirectoryInfo(sDir);

        foreach (var item in Directory.GetDirectories(sDir))
        {
            System.IO.FileInfo fInfo = new System.IO.FileInfo(item);
            temp.Add(fInfo);
            DirSearch(item, temp);
        }

        foreach (var item in di.GetFiles())
        {
            temp.Add(item);
        }
        return temp;
    }
}
